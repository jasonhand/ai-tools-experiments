---
layout: ../../layouts/ArticleLayout.astro
title: "Hands-On with eBPF and AI Tools - Accelerating Kernel-Level Observability"
description: "Explore how AI tools can help bridge the gap in kernel programming and make eBPF more accessible for rapid prototyping and learning."
diagram1: "../images/thumbnails/ep28.png"
HeroImg: "../images/thumbnails/ep28.png"
Tags: ["eBPF", "Kernel", "Security", "Infra", "ChatGPT", "Copilot"]
Summary: "This article explores how AI tools like ChatGPT and GitHub Copilot can make eBPF (Extended Berkeley Packet Filter) programming accessible to non-developers. The author, Scott Mabe, successfully used AI assistance to build a functional eBPF program that monitors changes to Linux's /etc/shadow file, going from idea to working prototype through an iterative process of prompting ChatGPT for starter code and using Copilot for debugging. While the AI-generated code required manual corrections and isn't suitable for production security monitoring, this approach dramatically reduced the learning curve and research time typically needed for kernel-level programming. The experiment demonstrates how AI tools are democratizing complex technologies like eBPF, enabling infrastructure professionals to rapidly prototype and learn through hands-on experimentation rather than extensive theoretical study, though mature professional tools are still needed for production deployments."
---

<img src={frontmatter.HeroImg} />
# {frontmatter.title}

## The Challenge: Bridging Kernel Programming and Rapid Prototyping

When I first set out to learn about eBPF (Extended Berkeley Packet Filter), my aim wasn't just to understand it in theory but to apply it in a way that would give me tangible, real-world insight. For many in infrastructure or security, the kernel can feel like an opaque, intimidating space—one where even seasoned engineers hesitate to experiment. But the real barrier isn't just technical complexity; it's also the time and expertise required to get something meaningful running.

As I put it in my conversation with Jason Hand, "the best way that I learn anything is by trying something, seeing if it breaks or if it actually works when I start." eBPF is especially intriguing because it lets us interact directly with the operating system kernel, opening the door to deep observability and control over critical resources like memory and network interfaces. Yet, for those new to kernel-level programming—or even seasoned developers short on time—the learning curve can be steep.

This is where generative AI tools like ChatGPT and GitHub Copilot are changing the game: can they help lower the bar for experimentation and learning with technologies like eBPF?

## Why eBPF Matters: Context and Key Use Cases

At its core, eBPF allows us to run sandboxed programs in the Linux kernel without modifying source code or loading kernel modules. This capability is a major leap for observability, security, and performance tooling. As I explained during our discussion, "eBPF... works very closely with the kernel of your operating system or your computer itself, which controls how your computer uses hardware... how I can control, like how I access memory or the network or anything at all. It's really cool."

### Suggested Visual: eBPF System Architecture

An effective diagram here would show the application/user space, kernel space, and hardware layers, highlighting how eBPF programs are loaded from user space, verified and run in kernel space, and can attach to system calls, network events, or tracepoints.

### Real-World Applications

At Datadog, we use eBPF across several products, including:

- **Universal Service Monitoring**
- **Cloud Network Monitoring**
- **Security Monitoring**

These leverage eBPF to collect telemetry, trace system calls, and detect suspicious events with minimal overhead. For students or professionals curious about security, I often recommend looking up eBPF—and sometimes even challenge them to do so on the spot. "I often will ask them if they know about eBPF and if they say no... I ask them to pull out their phone and then to look up eBPF."

For further reading, the [official eBPF documentation](https://ebpf.io/) and [Datadog's own resources](https://www.datadoghq.com/) are excellent starting points.

## Experimenting with eBPF Using Generative AI

My goal was to monitor critical Linux files—specifically the `/etc/shadow` file, which stores user privilege information. Unauthorized changes here are a major security concern. I wanted to see if I could build a simple eBPF-based monitor for this file with minimal prior programming experience, primarily using AI-assisted tooling.

I asked ChatGPT: "write a program to monitor changes to a file (e.g., /etc/shadow) on Linux using eBPF." The initial output wasn't perfect, but it was a starting point. As I explained, "Was it perfect out of the box? No. Was I able to use another tool, Copilot with GitHub and VS Studio Code to get it right? 100%."

### Sample Code Snippet (AI-generated and corrected)

```python
# This is a representative example; actual implementation may vary
from bcc import BPF

# eBPF program as a C string
bpf_program = """
int kprobe__vfs_write(struct pt_regs *ctx) {
    // Insert logic to filter for the /etc/shadow file
    bpf_trace_printk("vfs_write called!\\n");
    return 0;
}
"""

b = BPF(text=bpf_program)
print("Monitoring /etc/shadow for write attempts...")

while True:
    try:
        print(b.trace_readline())
    except KeyboardInterrupt:
        exit()
```
*Note: In practice, filtering for `/etc/shadow` and handling permissions requires additional logic.*

### Debugging with Copilot

After encountering a Python error ("bytes-like object is required, not string"), I pasted the error into Copilot, which quickly pointed out the issue and suggested a fix. The process was iterative—tweaking prompts, making corrections, and learning along the way. As I shared: "The time savings is almost as important as it lowers the frustration of searching the web for a solution and sifting through things that may not be relevant."

## Implementation Process and Key Decisions

The workflow looked like this:

1. **Prompt ChatGPT for a starter script** (Python, using BCC).
2. **Test and note errors** (e.g., type mismatches, missing logic for file filtering).
3. **Use Copilot for debugging and clarification**; paste errors and get targeted suggestions.
4. **Iterate quickly**: Modify code, rerun, and observe output.
5. **Manual validation**: Edit `/etc/shadow` (with caution) and verify immediate detection.

This workflow allowed me, as a self-described "infra guy" and not a developer, to quickly go from idea to working prototype. I didn't have to scour Stack Overflow or GitHub issues for hours.

### Trade-Offs and Limitations

- **Security:** This method is *not* suitable for production monitoring of critical files. As I noted, "Would I rely on this method to do production level monitoring of critical system files? That would be a no for that."
- **Code Quality:** The AI-generated code often needs manual correction and review, especially for security-sensitive tasks.
- **Performance:** eBPF is highly efficient, but naïve scripts may miss edge cases or introduce unnecessary overhead.

## Results and Observability

The result was a functional script that immediately detected changes to `/etc/shadow`, printing alerts in real-time:

> "If I go ahead... and write something silly in there and then 'w:q' to write and quit, actually wrote it, and then you see that I wrote it because that is the write attempt of shadow, so we know exactly that something happened... That was immediate. It was very much right away and I can close that."

While this experiment only scratched the surface—"this much of what we can do with eBPF"—it demonstrated how AI tooling can enable fast prototyping and learning.

## Practical Use Cases and Considerations

### Where This Approach Excels

- **Rapid Prototyping:** Quickly testing ideas without deep kernel programming expertise.
- **Learning by Doing:** "Theory is important but the practical application helps solidify what you’ve learned."
- **Experimentation:** Exploring new observability or security concepts in a safe, isolated environment.

### Deployment and Scalability

- **Production Readiness:** For robust, secure deployments, leverage mature tools (e.g., Datadog's eBPF-powered monitoring) rather than DIY scripts.
- **Resource Needs:** eBPF's efficiency means minimal CPU and memory impact, but poorly written programs can affect system stability.
- **Ethics:** Monitoring critical files or TTY activity has privacy and security implications. Always respect organizational policies and user consent.

## The Future: AI-Driven Observability and Greener Computing

Looking ahead, the intersection of kernel-level observability and AI promises even more powerful tools for system monitoring, troubleshooting, and automation. As I mentioned, "Future innovations I am interested in with regards to kernel level programming and AI would be gaining an understanding of how we can better tune AI models...not just in the time it takes to complete a query but more so when it comes down to the environmental impact."

Possible directions include:

- **AI-optimized eBPF programs for minimal energy consumption**
- **Automated anomaly detection on kernel events**
- **Self-healing infrastructure with feedback from kernel telemetry**

Open questions remain around making these tools more accessible, transparent, and sustainable.

## Recommendations for Getting Started

For those new to eBPF and AI-assisted coding, my advice is simple: start with hands-on goals. "Have an idea of something you want to accomplish," and use AI tools like ChatGPT and Copilot to scaffold your learning. Don't be afraid to experiment—even if you're not a developer.

For further exploration:

- [eBPF Official Documentation](https://ebpf.io/)
- [Datadog Homepage](https://www.datadoghq.com/)
- [ChatGPT](https://chat.openai.com/chat)
- [GitHub Copilot](https://github.com/features/copilot)

## Final Thoughts

The combination of eBPF and AI-powered coding tools has made kernel-level experimentation more approachable than ever, especially for those of us without a deep programming background. As I told Jason, "If you're afraid of doing something, because you're not a developer such as me... How do I get into there?... and try something that I think is cool?"

The answer: dive in, experiment, and let AI help you bridge the gap.

---

*This post is based on a conversation between Jason Hand and Scott Mabe. All quotes attributed to Scott Mabe unless otherwise noted.*